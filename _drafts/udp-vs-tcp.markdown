---
layout: post
title: "UDP vs. TCP"
date: 2016-06-18 22:43:03 +0800
categories: jekyll translate game-networking
---


# <span id="top"> __目录__ </span> 


# <span id="introduction"> __简介__ </span> [目录](#top)  

嗨，我是GlennFiedler，欢迎来到我的《[游戏程序员的网络须知](http://gafferongames.com/networking-for-game-programmers/)》文章系列的第一篇文章。

在这篇文章中，我们将介绍网络编程的最基本的概念：发送以及接收网络数据。这仅仅只是开始，是网络程序员最简单最基本的一部分，同样，关于什么是最好的行动方法(the best course of action), 也是十分的复杂以及晦涩。小心！如果你把这部分内容搞混，那么将来会在你的多人游戏中造成严重的影响。

你一定听说过sockets，并且可能意识到有两种主要类型：TCP和UDP。当我们开始写一个网络游戏时，首先需要选择使用哪种传输socket。我们是使用TCP，还是UDP，或者两者混用？

选择完全依赖于你想做什么样的游戏。从现在开始，在本文章系列中，我假设你要做一款动作游戏。比如你所知道的Halo，Battlefield 1942, Quake, Unreal, CounterStrke, Team Fortress等等。

考虑到我们要做一款动作游戏，我们将要仔细看看两种sockets类型的性能，并且深挖一下网络是如何工作的。一旦我们掌握了这些信息，就很容易做成正确选择。


# <span id="tcpip"> __TCP/IP__ </span> [目录](#top)  

TCP全称“传输控制协议”，IP全称“网际协议”。他们一起组成了你上网做事的脊骨，从浏览IRC到接发email，这些事情都建立在TCP/IP的基础之上。

如果你曾经使用过TCP socket，你就知道他是一个基于可靠连接的协议。这意味着你在两台机器之间建立起连接，然后从其中一台发送数据就想写一个文件一样，从另外一个机器接收数据就想读取一个文件。

这个连接是可靠有序的，意味着你发送的所有数据，在另外一端都会以同样的顺序接收到。它也是一个数据流，意味着TCP帮你把数据分成包，然后在发送到网络。

再一次，记住就像写一个文件。就是这么简单。


# <span id="ip"> __IP__ </span> [目录](#top)  

当涉及到TCP层的下一层IP层如何工作时，就完全站在了简单性的对立面(in stark contrast to)。

这里没有连接的概念，而是数据从一台电脑传输到下一台。你可以把这个过程比喻成在一个拥挤的房间里，把一张手抄便条从一个人传到下一个人，最终传到目的地，只是中间经过了许多手而已。

这不保证这个便条会到达指定的人手中。发送者只是把便条传递出去，并期待最好结果，除非接受者打算回复，否则发送者不知道便条是否送达。

当然，实际情况比这复杂的多，因为没有一个电脑知道把数据包快速发送到目的地的最正确路径。有些时候，IP发送同一个数据包的多份拷贝，这些拷贝数据包经由不同的路径发往目的地，大多在不同的时间点到达。

这是因为互联网是被设计成具有自我组织以及自我修复能力的，能够检测绕过连接问题(route around connectivity problems)。仔细想想底层具体发生的事情，还是超酷的。关于这些，你可以拜读经典书籍《TCP/IP详解》。


# <span id="udp"> __UDP__ </span> [目录](#top)  

如果我们想直接发送和接收数据包，而不再想写文件一样对待电脑间的通信，会怎么样？

我们可以使用UDP这样做。UDP全称“用户数据包协议”，和TCP一样，它是另外一个建立在IP层之上的协议，但是这次他仅仅是IP层的一个薄薄的包装，不再添加大量的特性以及复杂度。

使用UDP，我们可以发送一个数据包到一个目的IP(如112.140.20.10)以及端口(如52423)，那么它将要么经过一个又一个的电脑直到目的地，要么在半路上丢失。

在接收端，我们就坐在那里，监听一个特定的端口(如52423)，当一个数据包从任何一个电脑(记住这是无连接的)到来时，我们能够直到发送数据包的源电脑IP地址以及端口号，数据包的大小，并且可以读取数据包数据。

UDP是不可靠的协议。实战中，大多数发送的数据包会到达目的地，但是我们会有1-5%的丢包率，偶尔情况下，会有一段时间你的数据包一个也过不去(记住你的电脑和你的目的地中间有大量的电脑，并且可以出错)。

UDP不保证数据包的顺序。你按顺序发送1，2，3，4，5共5个数据包，他们完全可以乱序到达，如3，1，2，5，4。实战中，大多数时间他们会有序到达，但再一次，你不可以依赖这个。

最后，尽管UDP在IP层之上没做太多，但是它可以保证一件事情：如果你发送一个数据包，那么这个数据包要么全部送达目的地，要么根本送不到。所以，如果你发送了一个256字节的包到另外一台电脑，那么那台电脑不会仅仅收到数据包的前100字节，他一定会收到完整的256字节的数据。UDP提供这个保证已经足够，剩下的事情取决于你。


# <span id="tcpudp"> __TCP vs. UDP__ </span> [目录](#top)  

这里我们面临选择：使用TCP？还是使用UDP？

我们看一下两者的特性：

TCP:

* 基于连接的
* 保证可靠以及有序的
* 自动把你的数据拆分成包
* 保证不会发送数据太快而导致网络连接不能处理
* 简单易用，你收发数据就想读写一个文件

UDP:

* 没有连接的概念，你需要自行编码处理
* 不保证数据包的有序性，他们可能乱序到达，或者重复，甚至根本不会到达
* 你需要收到把你的数据拆分成包并且发送
* 你必须保证你不能发送数据太快而导致网络无力处理
* 如果一个包丢失了，你需要设计一个策略检测这种情况，并且在必要的时候重发数据

这时候选择看起来很清楚了，TCP做了我们想要的所有事情，并且简单易用，然而UDP让人痛不欲生，我们需要自行从头编写所有我们想要的。很明显，就用TCP，对不？

错！

开发一款FPS类型的网络动作游戏时，选择使用TCP是犯了最严重的错误。想知道为什么，你需要知道TCP在IP层之上做了什么，以至于所有事情看起来都这么简单!

# <span id="tcp-work"> 1 __How TCP really works__ </span> [目录](#top)  

TCP和UDP都建立在IP之上，但是他们完全不同。UDP行为十分像IP的行为，而TCP抽象出所有事情以至于你就想读写一个文件一样，掩盖了数据包的所有复杂性以及不稳定性。

那么它怎做到这些的呢？

首先，TCP是一个流协议，所以你只需要往一个流里写数据，然后TCP会保证数据会到达网络的另一端。因为IP是基于包，TCP基于IP，所以TCP必须要保你的流数据拆分成包。所以一些TCP代码会为你要发送的数据排队，当足够多的数据进入排队时，TCP会发送一个包到另外电脑。

如果多人游戏里你发送的都是小包的话，这就是一个问题。这里可能发生的事情是：TCP决定暂不发送你的数据，直到你缓存了足够多的数据以至于可以做成一个合理大小的包(比如大于100字节什么的)。因为你希望客户端玩家的输入可以尽快的发送到服务器，所以这就是一个问题。如果就想TCP处理小包一样，延迟它们或者堆积它们，客户端用户的体验将会十分糟糕。游戏网络的更新就会迟到以及不频繁，而不是我们想要的及时以及频繁。

你可以设置TCP的一个选项__TCP_NODELAY__来修复这个问题。这个选项是TCP不要等待足够的排队数据，而是直接发送你要发送的任何数据。这是通过禁用Nagle's algorithm实现的。

不幸的是，及时你设置了这个选项，对于多人游戏，TCP还是会有严重的问题。

根源在于TCP为给你呈现一个可靠，有序数据流的“假象”，而在丢包以及乱序包上的处理方式。


# <span id="tcpimple"> __How TCP implements reliability__ </span> [目录](#top)  

基本上，TCP把数据流拆分成数据包，通过不可靠的IP发送，然后在接收端接收数据包，并且重新构成数据流。

但是当一个数据包丢失时会发生什么？数据包乱序或者重复会发生什么？

TCP工作机制(参考《TCP/IP详解》)超级复杂，这里不打算深究。本质上，TCP发送一个数据包，等一段时间若没有收到这个数据包的确认(ack)，就会认为这个包丢失，这时候会把丢失的包重新发送。重复的数据包在接收端会被丢掉，乱序数据包会被重新排序，这样事情就会可靠有序。

如果我们试图使用TCP同步，当一个数据包丢失并且等一下需要重发这个数据包时，问题就来了。是的，即使更多的数据到达需要发送，这些新数据会放进到队列中，你不能访问它们，知道丢失的数据包被成功传送。重发一个数据包需要多长时间？考虑一下，TCP至少需要一个往返延迟来确认这个数据包需要重发，一般情况下是`2*RTT`时间，另外还需要一个单程时间把重发数据包发送到接收端。假设你有125ms的ping，最好情况下，你大概需要等待大概1/5秒让一个数据包重发，最坏情况，你需要等待0.5秒甚至更多(考虑到重发数据也失败怎么办？)。如果TCP认为丢包是网络拥堵并且要退后(backs off)，会发生什么？是的，TCP会这么做，有意思了！


# <span id="tcp-nerver-se"> __Why you should nerver use TCP to network time critical data__ </span> [目录](#top)  

在像FPS这样的实时游戏中使用TCP与在浏览网页，或者email，或者其他大多数应用使用TCP不同，多人游戏需要数据包及时实时传输。对于游戏的大部分数据，例如玩家输入以及角色位置，一秒之前怎么样并不重要，你只关心当前的数据。TCP并不是为这个而设计的。

考虑一个非常简希望单的多人游戏例子，例如动作游戏里的射击手，你希望用非常简单的方式通信，游戏中的每一帧，你发送客户端的输入(例如键盘按键，鼠标输入)到服务器，每一帧中，服务器处理每一个玩家的输入，更新状态，并且发送游戏内物体对象的当前位置到客户端，让客户端来渲染。

所以在我们的简单多人游戏中，当一个数据包丢失时，所有事情需要停下来，等待这个数据包重新发送出去。客户端上的物体收不到更新，所以会站着不动，在服务器端收不到客户端的输入，所以玩家不能移动或者射击。当重新发送的数据包最终到达时，你收到了这个过时、陈旧的数据信息，然而你已经不再关心了。另外，在发送队列中等待的数据包同时到达，你不得不在一帧之中处理所有这些信息。所有事情都聚集起来了！

不幸的是，TCP的这个特性你不能修正，并且你也不想修正，它就是TCP的基本特性。靠这个特性，TCP让不稳定的、基于包的网络看起来是一个可靠有序的数据流。

关键是，我们不需要一个可靠有序的数据流。

我们希望我们的数据能够尽可能快的发送到服务器，而不需要等待丢包重新被发送。

这就是为什么你永远不要在时间敏感数据上使用TCP。


# <span id="tcp-with-udp"> __Why can't I use _both_ UDP and TCP?__ </span> [目录](#top)  
